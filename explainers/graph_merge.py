from explainers.explainer import Explainer
from sklearn.ensemble import IsolationForest as skIsolationForest
import numpy as np
from utilities.metrics import euclidean_distance
import networkx as nx
from networkx.algorithms.approximation import clique


class GraphMerge(Explainer):
    def __init__(self, model, distance_metric="Euclidean", hyperparameters=None):
        self.model = model
        self.hyperparameters = hyperparameters

        # select the distance function which corresonds to the provided distance metric
        if distance_metric == "Euclidean":
            self.distance_fn = euclidean_distance
        else:
            print("Unknown distance function {}, using Euclidean distance for explainer".format(distance_metric))
            self.distance_fn = euclidean_distance

    def explain(self, x, y):
        '''
        A method for explaining the samples in x by finding the best candidate contrastive examples generated by the model's detectors

        Parameters
        ----------
        x               : an array of samples, dimensions (nsamples, nfeatures)
        y               : an array of labels which correspond to the labels, (nsamples, )

        Returns
        -------
        best_examples : an array of contrastive examples with dimensions (nsamples, nfeatures). Each of final_examples[i] corresponds to
        the best examples which explains x[i] from those suggested by the detectors
        '''

        # !WARNING : This method only defined for an ensemble containing only a single random forest detector

        # build a graph to represent the feature similarities between trees
        rf_detector = self.model.detectors[0]
        adjacency = rf_detector.get_tree_adjacency()
        adjacency = np.floor(adjacency)  # consider only fully disjoint trees for merging

        # create a graph from the adjacency matrix using networkx
        G = nx.Graph(adjacency)

        # identify the largest set of trees which are fully disjoint in the features they use this is done by finding the largest complete (i.e. fully connectected) subgraph
        fully_disjoint_trees = clique.max_clique(G)  # returns a set of node indices representing trees in the forest

        # get a candidate contrastive example for each sample from each tree in the forest
        candidates = rf_detector.get_candidate_examples_treewise(x, y)

        xprime = x.copy()  # an array for the constructed contrastive examples

        for tree_id in fully_disjoint_trees:
            # merge the examples from each tree into xprime, taking only the features which that tree used
            features_used = rf_detector.get_features_used(tree_id)
            xprime[:, features_used] = candidates[tree_id, :, features_used].T

        return xprime
